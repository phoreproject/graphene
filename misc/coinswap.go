package misc

// This file is for swapping coins from Phore to Synapse

import (
	"encoding/json"

	"github.com/phoreproject/synapse/chainhash"
)

type proofEntry struct {
	left bool
	hash *chainhash.Hash
}

func computeCombinedHash(left *chainhash.Hash, right *chainhash.Hash) chainhash.Hash {
	h := chainhash.HashH(chainhash.HashB(append(left[:], right[:]...)))
	return h
}

func computeProofRootHash(hash *chainhash.Hash, entries []proofEntry) chainhash.Hash {
	h := *hash
	for i := 0; i < len(entries); i++ {
		if entries[i].left {
			//fmt.Printf("Input L: %s R: %s\n", entries[i].hash.String(), h.String())
			h = computeCombinedHash(entries[i].hash, &h)
			//fmt.Printf("L compute: %s L\n", h.String())
		} else {
			//fmt.Printf("Input L: %s R: %s\n", h.String(), entries[i].hash.String())
			h = computeCombinedHash(&h, entries[i].hash)
			//fmt.Printf("R compute: %s\n", h.String())
		}
	}
	return h
}

type jsonProofEntry struct {
	Left int    `json:"left"`
	Hash string `json:"hash"`
}

// The text is generated by SynapseSwap::proofListToText in C++
func textToProofList(text string) []proofEntry {
	entries := &[]*jsonProofEntry{}
	err := json.Unmarshal([]byte(text), entries)
	if err != nil {
		panic(err)
	}
	proofList := []proofEntry{}
	for _, e := range *entries {
		h, _ := chainhash.NewHashFromStr(e.Hash)
		proofList = append(proofList, proofEntry{
			left: e.Left != 0,
			hash: h,
		})
		//fmt.Printf("%s\n", e.Hash)
	}
	return proofList
}
